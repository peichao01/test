// Generated by CoffeeScript 1.6.2
(function() {
  var Constants, EventEmitter, WebSocketRequest, WebSocketServer, extend, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  extend = require('./util').extend;

  util = require('util');

  EventEmitter = require('events').EventEmitter;

  WebSocketRequest = require('./WebSocketRequest');

  Constants = require('./Constants');

  WebSocketServer = (function(_super) {
    __extends(WebSocketServer, _super);

    function WebSocketServer(config) {
      this.handleRequestAccepted = __bind(this.handleRequestAccepted, this);      this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this)
      };
      this.connections = [];
      if (config) {
        this.mount(config);
      }
    }

    WebSocketServer.prototype.mount = function(config) {
      this.config = extend({
        httpServer: null,
        maxReceivedFrameSize: 0x10000,
        maxReceivedMessageSize: 0x10000,
        fragmentOutgoingMessages: true,
        fragmentationThreshold: 0x4000,
        keepalive: true,
        keepaliveInterval: 20000,
        dropConnectionOnKeepaliveTimeout: true,
        keepaliveGracePeriod: 10000,
        useNativeKeepalive: false,
        assembleFragments: true,
        autoAcceptConnections: false,
        disableNagleAlgorithm: true,
        closeTimeout: 5000
      }, config);
      if (this.config.httpServer) {
        return this.config.httpServer.on('upgrade', this._handlers.upgrade);
      } else {
        throw new Error('You must specify an httpServer on which to mount the WebSocket server');
      }
    };

    WebSocketServer.prototype.unmount = function() {
      return this.config.httpServer.removeListener('upgrade', this._handlers.upgrade);
    };

    WebSocketServer.prototype.closeAllConnections = function() {
      return this.connections.forEach(function(connection) {
        return connection.close();
      });
    };

    WebSocketServer.prototype.broadcast = function(data) {
      if (Buffer.isBuffer(data)) {
        return this.broadcastBytes(data);
      } else {
        return this.broadcastUTF(data);
      }
    };

    WebSocketServer.prototype.broadcastUTF = function(utfData) {
      return this.connections.forEach(function(connection) {
        return connection.sendUTF(utfData);
      });
    };

    WebSocketServer.prototype.broadcastBytes = function(binaryData) {
      return this.connections.forEach(function(connection) {
        return connection.sendBytes(binaryData);
      });
    };

    WebSocketServer.prototype.shutDown = function() {
      this.unmount();
      return this.closeAllConnections();
    };

    WebSocketServer.prototype.handleUpgrade = function(req, socket, head) {
      var e, wsRequest;

      wsRequest = new WebSocketRequest(socket, req, this.config);
      try {
        wsRequest.readHandshake();
      } catch (_error) {
        e = _error;
        wsRequest.reject(e.httpCode || 400, e.message, e.headers);
        if (Constants.DEBUG) {
          console.log("" + (new Date()) + " WebSocket: Invalid handshake: " + e.message);
        }
        return;
      }
      wsRequest.once('requestAccepted', this._handlers.requestAccepted);
      if (!this.config.autoAcceptConnections && this.listeners('request').length > 0) {
        return this.emit('request', wsRequest);
      } else if (this.config.autoAcceptConnections) {
        return wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
      } else {
        return wsRequest.reject(404, 'No handler is configured to accept the connection.');
      }
    };

    WebSocketServer.prototype.handleRequestAccepted = function(connection) {
      connection.once('close', function(closeReason, description) {
        return this.handleConnectionClose(connection, closeReason, description);
      });
      this.connection.push(connection);
      return this.emit('connect', connect);
    };

    WebSocketServer.prototype.handleConnectionClose = function(connect, closeReason, description) {
      var index;

      index = this.connections.indexOf(connection);
      if (index !== -1) {
        this.connections.splice(index, 1);
      }
      return this.emit('close', connection, closeReason, description);
    };

    return WebSocketServer;

  })(EventEmitter);

  module.exports = WebSocketServer;

}).call(this);
